const moment = require('moment');
const {query} = require('oo');
const _ = require('lodash');
class Model {

    constructor(){
        this.fields = {
            CreationTime: {type: 'time', readonly: true, internal: true},
            CreationDate: {type: 'date', readonly: true, internal: true},
            CreationUser: {type: 'string', readonly: true, internal: true},
            UpdateUser: {type: 'string', readonly: true, internal: true}
        };
        this.unique = [];
        this.__singleton = false;
        this.__schemaSetting = false;
        this.init();
    }

    async init(){
        this.fields = {...this.fields, ...this.getFields()};
        for (let f in this.fields) this[f] = undefined;
        this.unique = [...this.unique, ...this.getUniqueFields()];
    }

    registerFieldsComponents(Vue){
        if (this.__schemaSetting) this.registerSchema(Vue);
        for (let field in this.fields){
            if (this.fields[field].type === 'component')
                this.registerComponent(Vue,field);
        }
    }

    registerImageUploader(Vue,field){
        let self = this;
        const q = require ('quasar');
        let t = `
        <div class="row no-wrap" style='width:1400px;'>
            <q-uploader
            style="max-width: 300px; height:30vh; margin: 15px; width:400px;"
            url="/upload"
            label="Restricted to images"
            accept=".jpg, image/*"
            @uploaded='uploaded'
            />
            <q-scroll-area
            horizontal
            style="height: 300px; width: 1000px; margin: 15px"
            class="bg-grey-1 rounded-borders"
          >
            <div class="row no-wrap">
              <q-card
              style="width: 300px" class="q-pa-sm"
              v-for ='i in cImages'
              :key = 'i'
              >
              <q-card-section horizontal>
                  <q-img :src= 'i' />
                  <q-card-actions vertical class="justify-around">
                  <q-btn flat round color='grey' icon="delete" @click='remove(i)'/>
              </q-card-actions>
              </q-card-section>
              </q-card>
            </div>
          </q-scroll-area>
        </div>
        `;
        Vue.component('Field'+field, {
            template: t,
            components: {...q},
            name: 'Field'+field,
            props: {
                value: {
                    type: String
                }
            },
            model: {
                prop: 'v-model',
                event: 'input'
            },
            data() {
                return {
                    cImages:[]
                };
            },
            watch: {
                value: function () {
                    this.cImages = this.value ? this.value.split(','):[];
                }
            },
            methods: {
                uploaded: function (inf){
                    console.log(inf.xhr.response);
                    let n = this.value ? this.value+','+inf.xhr.response:inf.xhr.response;
                    this.$emit('input', n);
                },
                remove: function (e) {
                    let n = this.value.split(',').filter(r => r !== e);
                    this.cImages = n;
                    this.$emit('input',n.toString());
                }
            },
            mounted() {
                this.cImages = this.value ? this.value.split(','):[];
            }
        });
    }

    getSchemaName(){
        return null;
    }

    isSchema(){
        return this.__schemaSetting;
    }

    registerComponent(Vue,field){
    }

    registerSchema(Vue){
    }

    getFields(){
        return {};
    }

    getUniqueFields(){
        return [];
    }

    getFieldsName() {
        return Object.keys(this.fields);
    }

    loadFromRow(desc) {
        for (let f in desc) this[f] = desc[f];
    }

    name() {
        return this.constructor.name;
    }

    fieldStringTypes() {
        return ['string', 'date', 'time', 'set', 'textareas', 'component'];
    }

    async delete() {
        if (!this.internalId) return {status:false, res: 'no id'};
        let raw = `DELETE FROM ${this.name()} WHERE internalId = ${this.internalId}`;
        try {
            let q = new query();
            q._raw = raw;
            q = await q.fetch();
            if (typeof q.status !== 'undefined' && !q.status) return q;
            return {status:true, res:q};
        }catch (err){
            return {status:false, res:err};
        }
    }

    getMysqlValue(f){
        let field = this.fields[f];
        if (typeof this[f] === 'undefined') return 'NULL';
        if (field.type === 'boolean') return this[f] ? true : false;
        if (this.fieldStringTypes().includes(field.type)) return this[f] ? `"${this[f].toString()}"` : 'NULL';
        if (field.type === 'integer' && !this[f] && this[f] !== 0) return 0;
        else if (field.type === 'integer' && this[f]) return parseInt(this[f]);
        if (field.type === 'value' && !this[f] && this[f] !== 0) return 0.00;
        else if (field.type === 'value' && this[f]) parseFloat(this[f]);
        return 'NULL';
    }

    getFieldValueDict(){
        let fields = this.getFieldsName();
        let d = {};
        for (let f of fields){
            if (this.fields[f].internal) continue;
            d[f] = this[f];
        }
        return d;
    }

    async save(){
        if (this.__singleton){
            let q = await this.bringAll();
            if (q.length) this.internalId = 1;
        }
        let d = {
            fields: this.getFieldValueDict(),
            table: this.name(),
            internalId: this.internalId
        };
        try{
            let q = new query();
            q = await q.update(d);
            if (typeof q.status !== 'undefined' && !q.status) return q;
            return {status:true, res:q};
        }catch(e){
            return {status:false, res:e};
        }
    }

    async bringAll(cond = {}) {
        let raw = "SELECT * FROM " + this.name();
        let res = new query(raw);
        return await res.fetch();
    }

}

module.exports = Model;