const moment = require('moment');
const {query} = require('oo');
const _ = require('lodash');
class Model {

    constructor(){
        this.fields = {
            CreationTime: {type: 'time', readonly: true, internal: true},
            CreationDate: {type: 'date', readonly: true, internal: true},
            CreationUser: {type: 'string', readonly: true, internal: true}
        };
        this.unique = [];
        this.__singleton = false;
        this.__schemaSetting = false;
        this.init();
    }

    async init(){
        this.fields = {...this.fields, ...this.getFields()};
        for (let f in this.fields) this[f] = undefined;
        this.unique = [...this.unique, ...this.getUniqueFields()];
    }

    registerFieldsComponents(Vue){
        if (this.__schemaSetting) this.registerSchema(Vue);
        for (let field in this.fields){
            if (this.fields[field].type === 'component')
                this.registerComponent(Vue,field);
        }
    }

    getSchemaName(){
        return null;
    }

    isSchema(){
        return this.__schemaSetting;
    }

    registerComponent(Vue,field){
    }

    registerSchema(Vue){
    }

    getFields(){
        return {};
    }

    getUniqueFields(){
        return [];
    }

    getFieldsName() {
        return Object.keys(this.fields);
    }

    loadFromRow (desc) {
        for (let f in desc) this[f] = desc[f];
    }

    name () {
        return this.constructor.name;
    }

    fieldStringTypes () {
        return ['string', 'date', 'time', 'set', 'textareas', 'component'];
    }

    async delete() {
        if (!this.internalId) return {status:false, res: 'no id'};
        let raw = `DELETE FROM ${this.name()} WHERE internalId = ${this.internalId}`;
        try {
            let q = new query();
            q._raw = raw;
            q = await q.fetch();
            if (typeof q.status !== 'undefined' && !q.status) return q;
            return {status:true, res:q};
        }catch (err){
            return {status:false, res:err};
        }
    }

    getMysqlValue(f){
        let field = this.fields[f];
        if (typeof this[f] === 'undefined') return 'NULL';
        if (field.type === 'boolean') return this[f] ? true : false;
        if (this.fieldStringTypes().includes(field.type)) return this[f] ? `"${this[f].toString()}"` : 'NULL';
        if (field.type === 'integer' && !this[f] && this[f] !== 0) return 0;
        else if (field.type === 'integer' && this[f]) return parseInt(this[f]);
        if (field.type === 'value' && !this[f] && this[f] !== 0) return 0.00;
        else if (field.type === 'value' && this[f]) parseFloat(this[f]);
        return 'NULL';
    }

    getFieldValueDict(){
        let fields = this.getFieldsName();
        let d = {};
        for (let f of fields){
            if (this.fields[f].internal) continue;
            d[f] = this[f];
        }
        return d;
    }

    async save(){
        // let stringtypes = this.fieldStringTypes();
        let u;
        if (this.__singleton){
            let q = new query ();
            q._raw = 'SELECT * FROM ' + this.name();
            q = await q.fetch();
            if (q.length) this.internalId = 1;
        }
        if (this.internalId){
            // u = `UPDATE ${this.name()} SET `;
            // let sets = [];
            // for (let f in this.fields){
            //     if (this.fields[f].internal) continue;
            //     let ff = this.getMysqlValue(f);
            //     // if (stringtypes.includes(this.fields[f].type))
            //     //     if (typeof ff !== 'undefined') ff = `"${ff.toString()}"`;
            //     //     else ff = 'NULL';
            //     // if (this.fields[f].type === 'boolean')
            //     //     if(!ff) ff = 0;
            //     //     else ff = 1;
            //     sets.push(`${f} = ${ff} `);
            // }
            // u += sets.join(',');
            // u += ` WHERE internalId = ${this.internalId}`;
            let d = {
                fields: this.getFieldValueDict(),
                table: this.name(),
                internalId: this.internalId
            };
            try{
                let q = new query();
                q = await q.update(d);
                if (typeof q.status !== 'undefined' && !q.status) return q;
                return {status:true, res:q};
            }catch(e){
                return {status:false, res:e};
            }
        }else{
            let fields = this.getFieldsName();
            u = `INSERT INTO ${this.name()} `;
            u += ` (${fields.toString()}) `;
            u += `VALUES `;
            this.CreationDate = moment().format('YYYY-MM-DD');
            let sets = [];
            for (let f of fields){
                let ff = this.getMysqlValue(f);
                // if (stringtypes.includes(this.fields[f].type))
                //     if (typeof ff !== 'undefined') ff = `"${ff.toString()}"`;
                //     else ff = 'NULL';
                // if (this.fields[f].type === 'boolean')
                //     if(ff === false) ff = 0;
                //     else ff = 1;
                sets.push(ff);
            }
            u += ` (${sets.toString()}) `;
        }
        try {
            let q = new query();
            q._raw = `${u}`;
            q = await q.fetch();
            if (typeof q.status !== 'undefined' && !q.status) return q;
            return {status:true, res:q};
        }catch (err){
            return {status:false, res:err};
        }
        
    }

    async bringAll(cond = {}) {
        let raw = "SELECT * FROM " + this.name();
        let res = new query(raw);
        return await res.fetch();
    }

}

module.exports = Model;